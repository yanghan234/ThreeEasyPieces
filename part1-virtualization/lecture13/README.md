# The Abstraction: Address Spaces

## Multiprogramming and Time Sharing
早期实现多进程切换的时候，每个运行中的进程独立占据所有内存，在进程切换时将内存中的信息存入磁盘。但是这样的做法非常慢。因此在进程切换的时候，我们更希望需要的信息已经在内存中，这样速度会快很多。

将不同进程的信息都放入内存的做法又产生了另一个需求，那就是内存中信息的保护。我们显然不希望，一个进程可以随意地读取或修改另一个进程中的内容。

## The address space
地址空间是对物理内存的抽象。每个程序的地址空间包含(以C语言为例），代码区（.text)，静态区（.static, .bss)，堆(heap)，栈（stack），共享库(shared library)。这些区域在物理内存中的位置对于程序来说都是未知的。

每当程序发起一次内存访问，系统都会通过一些列过程将其访问的逻辑地址翻译为物理内存中的地址。

## Goals

逻辑地址翻译为物理内存中的地址。

## Goals
1. virtual memory对于程序应该是透明的，即程序根本无法判断它手上的内存地址是不是经过抽象的地址。并且每个程序都相信自己独立拥有物理内存。
2. 实现virtual memory不应该付出过多额外开销。
3. virtual memory应当为不同进程的信息提供保护。

